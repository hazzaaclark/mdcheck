/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Checksum Tool */

/* THIS FILE REFERS TO THE MAIN FUNCTIONALITY OF THE PROGRAM */

/* NESTED INCLUDES */

#include "util.h"

/* COMPUTE THE CHECKSUM BY DETERMINING THE SOURCE OF THE FILE */
/* THE ORIGIN IN WHICH THE OFFSET HEX VALUE EXISTS INSIDE OF
/* THE BINARY OFFSET RELATIVE TO THE HANDLE */

/* THE CHECKSUM IS DETERMINED BY THE VECTOR TABLE OF THE M68K */
/* TO DETERMINE IF ANY IRQ'S HAVE TO BE CALLED TO DETECT */
/* ILLEGAL OPERATIONS OR AN INACCESSIBLE CHUNK OF MEMORY */

#ifdef USE_HEX_ARGS

CHECKSUM::COMPUTE* COMPUTE_CHECKSUM(CHECKSUM::OPEN_FILE* OF, FILE_TYPE::FILE_SIZE* FILE_SIZE)
{
    fseek(*OF, CHECK_START_OFFSET, SEEK_SET);
    fseek(*OF, 0, SEEK_END);

    *FILE_SIZE = ftell(*OF);

    for (long C = CHECK_START_OFFSET; C < *FILE_SIZE; C += NUM_BYTES)
    {
        SUM_LENGTH = WORD_TO_INT(OF);
        CALCULATED_CHECKSUM = SUM_LENGTH;
    }

    return CALCULATED_CHECKSUM & CHECK_MASK;
}

#undef BIT_ARGS

/* ACCESS THE FILE'S CONTENTS AND CONVERT THOSE BYTEWISE VALUES TO INTS */
/* READY TO BE PARSED */

/* CONVERT THE BYTES INTO INTS TO COMMUNICATE WITH THE CARTRIDGE'S VECTOR TABLE */

/* SEE M68K VECTOR TABLE: https://wiki.neogeodev.org/index.php?title=68k_vector_table */

BIT::BYTE_TO_INT* BYTE_TO_INT(CHECKSUM::OPEN_FILE* OF)
{
    return fgetc(*OF);
}

/* IN ACCORDANCE WITH THE STATUS REGISTER ON THE M68K, THIS ALLOWS THE CARTRIDGE */
/* TO COMMUNICATE WITH THE CONDITION CODES */

/* TAKING INTO ACCOUNT MSB/LSB, WE DETERMINE THE HIGH AND LOW ORDER OF */
/* THE BYTE ORIENTATION TO EQUATE 16 BITS (1 WORD) */

/* SEE FIGURE 2-5: https://www.nxp.com/docs/en/reference-manual/MC68000UM.pdf#page=21 */

BIT::WORD_TO_INT* WORD_TO_INT(CHECKSUM::OPEN_FILE* OF)
{
    BIT_HI = BYTE_TO_INT(OF) << 8;
    BIT_LO = BYTE_TO_INT(OF) & 0xFF;
    return BIT_SUM;
}

/* VERIFY WHICH CONSOLE THE .BIN OR .MD FILE REPRESENTS */
/* THIS IS DETERMINED BY A STRING COMPARISON */

/* WE DETERMINE THIS IN RELATION TO THE BYTE RANGE OF THE STATUS REGISTER */
/* THAT GOVERNS THE VECTORS ESTABLISHED ON THE TABLE TO DETERMINE THE */
/* CARTRIDGE REGION */

BIT::CONSOLE_HEADER* VERIFY_CONSOLE(CHECKSUM::OPEN_FILE* OF, FILE_TYPE::CONSOLE_NAME* CONSOLE)
{
    fseek(*OF, BYTE_RANGE, SEEK_SET);
    fread(CONSOLE, sizeof(char), 15, *OF);
    CONSOLE[15] = '\0';

    if (strcmp(*CONSOLE, "SEGA Mega Drive") == 0 || strcmp(*CONSOLE, "SEGA Genesis") == 0)
    {
        return 1;
    }

    return 0;
}

BIT::CHECKSUM_HEADER* READ_CHECKSUM_HEADER(CHECKSUM::OPEN_FILE* OF)
{
    fseek(*OF, CHECK_HANDLE_OFFSET, SEEK_SET);
    return WORD_TO_INT(OF);
}

CHECKSUM::READ* READ_CONTENTS(CHECKSUM::OPEN_FILE* OF)
{
    fseek(*OF, CHECK_HANDLE_OFFSET, SEEK_SET);
    return WORD_TO_INT(OF);
}

CHECKSUM::WRITE* WRITE_CONTENTS(CHECKSUM::OPEN_FILE* OF)
{
    fseek(*OF, CHECK_HANDLE_OFFSET, SEEK_SET);
    fputc(BIT_HI, *OF);
    fputc(BIT_LO, *OF);
    BIT_HI = CALCULATED_CHECKSUM >> 8 & 0xFF;
    BIT_LO = CALCULATED_CHECKSUM & 0xFF;

    return BIT_SUM;
}

CHECKSUM::PRINT_SUM* PRINT_RESULT()
{
    printf("0x%0x4X", SUM_LENGTH);
}

ERROR::OPEN_FILE_ERR* OPEN_ERROR(FILE_TYPE::CONSOLE_FILE* CONSOLE)
{
    if (*CONSOLE == NULL)
    {
        printf("Failed to open file: %s\n");
        return 1;
    }
    return 0;
}

ERROR::VERIFY_CONSOLE_ERR* VERIFY_ERROR(FILE_TYPE::CONSOLE_FILE* CONSOLE)
{
    if (!VERIFY_CONSOLE())
    {
        FILE_ERROR;
        fclose(*CONSOLE);
        return 1;
    }
    return 0;
}

#endif

int main(int argc, char** argv)
{
    if (argc != 2)
    {
        printf("Usage: %s <path>\n", argv[0]);
        return 1;
    }

    FILE_TYPE::CONSOLE_FILE = fopen(argv[1], "rb");
    FILE_TYPE::FILE_PATH* PATH;
    PATH = argv[1];

    if (OPEN_ERROR(&FILE_TYPE::CONSOLE_FILE))
    {
        return 1;
    }

    printf("Reading Checksum IRQ from:\n");

    if (VERIFY_ERROR(&FILE_TYPE::CONSOLE_FILE))
    {
        return 1;
    }

    printf("Header Checksum = ");
    HEADER_CHECKSUM = READ_CHECKSUM_HEADER(&FILE_TYPE::CONSOLE_FILE);
    printf("\n");

    COMPUTE_CHECKSUM(&FILE_TYPE::CONSOLE_FILE, &FILE_TYPE::FILE_SIZE);
    BYTE_TO_INT(&FILE_TYPE::CONSOLE_FILE);
    WORD_TO_INT(&FILE_TYPE::CONSOLE_FILE);
    PRINT_RESULT();

    fclose(FILE_TYPE::CONSOLE_FILE);

    return 0;
}
