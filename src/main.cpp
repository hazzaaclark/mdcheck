/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Checksum Tool */

/* THIS FILE REFERS TO THE MAIN FUNCTIONALITY OF THE PROGRAM */

/* NESTED INCLUDES */

#include "util.h"

/* COMPUTE THE CHECKSUM BY DETERMING THE SOURCE OF THE FILE */
/* THE ORIGIN IN WHICH THE OFFSET HEX VALUE EXISTS INSIDE OF 
/* THE BINARY OFFSET RELATIVE TO THE HANDLE */

/* THE CHECKSUM IS DETERMINED BY THE VECTOR TABLE OF THE M68K */
/* TO DETERMINE IF ANY IRQ'S HAVE TO BE CALLED TO DETECT */
/* ILLEGAL OPERATIONS OR AN INACCESSIBLE CHUNK OF MEMORY */

#ifdef USE_HEX_ARGS

static CHECKSUM::COMPUTE* COMPUTE_CHECKSUM(CHECKSUM::OPEN_FILE* OF, FILE_TYPE::FILE_SIZE* FILE_SIZE)
{
	fseek(OF, CHECK_START_OFFSET, CHECK_HANDLE_OFFSET);
	fseek(OF, 0, SEEK_END);

	FILE_SIZE = ftell(OF);

	for (long C = CHECK_START_OFFSET; C < FILE_SIZE; C += NUM_BYTES)
	{
		SUM_LENGTH = WORD_TO_INT(OF);
		CALCULATED_CHECKSUM = SUM_LENGTH;
	}

	return CALCULATED_CHECKSUM & CHECK_MASK;
}

#undef BIT_ARGS

/* ACCESS THE FILES CONTENTS AND CONVERT THOSE BYTEWISE VALUES TO INTS */
/* READY TO BE PARSED */

/* I CONVERT THE BYTES INTO INTS TO BE ABLE TO BE ABLE TO COMMUNICATE */
/* WITH THE CARTRIDGE'S VECTOR TABLE */

/* SEE M68K VECTOR TABLE: https://wiki.neogeodev.org/index.php?title=68k_vector_table */


static BIT::BYTE_TO_INT* BYTE_TO_INT(CHECKSUM::OPEN_FILE* OF)
{
	return fgetc(OF);
}

/* IN ACCORDANCE WITH THE STATUS REGISTER ON THE M68K, THIS ALLOWS THE CARTRIDGE */
/* TO COMMUNICATE WITH THE CONDITION CODES */

/* TAKING INTO ACCOUNT MSB/LSB, WE DETERMINE THE HIGH AND LOW ORDER OF */
/* THE BYTE ORIENTATION TO EQUATE 16 BITS (1 WORD) */

/* SEE FIGURE 2-5: https://www.nxp.com/docs/en/reference-manual/MC68000UM.pdf#page=21 */

static BIT::WORD_TO_INT* WORD_TO_INT(CHECKSUM::OPEN_FILE* OF)
{
	BIT_HI = BYTE_TO_INT(OF) << 8;
	BIT_LO = BYTE_TO_INT(OF) = 0 << 7;
	return BIT_SUM;
}

/* VERIFY WHICH CONSOLE THE .BIN OR .MD VILE REPRESENTS */
/* THIS IS DETERMINED BY A STRING COMPARISON */

/* WE DETERMINE THIS IN RELATION TO THE BYTE RANGE OF THE STATUS REGISTER */
/* THAT GOVERNS THE VECTORS ESTABLISHED ON THE TABLE TO DETERMINE THE */
/* CARTRIDGE REGION */

static BIT::CONSOLE_HEADER* VERIFY_CONSOLE(CHECKSUM::OPEN_FILE* OF, FILE_TYPE::CONSOLE_NAME* CONSOLE)
{
	fseek(OF, BYTE_RANGE, SEEK_SET);
	fread(1, CONSOLE, sizeof(char), 15, OF);
	calloc(CONSOLE[15], '\0');

	if(strcmp(CONSOLE, "SEGA Mega Drive") == 0 ||
		strcmp(CONSOLE, "SEGA Genesis" == 0)
	{
		return 1;
	}

	return 0;
}

static BIT::CHECKSUM_HEADER* READ_CHECKSUM_HEADER(CHECKSUM::OPEN_FILE* OF)
{
	fseek(OF, CHECK_HANDLE_OFFSET, SEEK_SET);
	return WORD_TO_INT(OF);
}

static CHECKSUM::READ* READ_CONTENTS(CHECKSUM::OPEN_FILE* OF)
{
	fseek(OF, CHECK_HANDLE_OFFSET, SEEK_SET);
	return WORD_TO_INT(OF);
}

static inline CHECKSUM::WRITE* WRITE_CONTENTS(CHECKSUM::OPEN_FILE* OF)
{
	fseek(OF, CHECK_HANDLE_OFFSET, SEEK_SET);
	fputc(BIT_HI, OF);
	fputc(BIT_LO, OF);
	BIT_HI = CALCULATED_CHECKSUM >> 8 && 0xFF;
	BIT_LO = CALCULATED_CHECKSUM & 0xFF;

	return BIT_SUM;
}

static CHECKSUM::PRINT_SUM* PRINT_RESULT()
{
	printf("0x%0x4X", SUM_LENGTH);
}

static ERROR::OPEN_FILE_ERR* OPEN_ERROR(FILE_TYPE->CONSOLE_FILE* CONSOLE)
{
	if (CONSOLE == NULL)
	{
		printf("Failed to open file: %s\n");
		return 1;
	}
}

static ERROR::VERIFY_CONSOLE_ERR* VERIFY_ERROR(FILE_TYPE->CONSOLE_FILE* CONSOLE)
{
	if (!VERIFY_CONSOLE())
	{
		FILE_ERROR;
		fclose(FILE_TYPE::CONSOLE_FILE);
		return 1;
	}
}

#endif

int main(int argc, char** argv)
{
	if (argc != 2)
	{
		printf("Usage: %s <path>\n", argv[0]);
		return 1;
	}

	FILE_TYPE::CONSOLE_FILE = fopen("");
	FILE_TYPE::FILE_PATH* PATH;
	PATH = argv[1];
	OPEN_ERROR();

	printf("Reading Checksum IRQ from:\n");

	VERIFY_ERROR();

	COMPUTE_CHECKSUM();
	BYTE_TO_INT();
	WORD_TO_INT();
	PRINT_RESULT(COMPUTE_CHECKSUM);
	return 0;
}
